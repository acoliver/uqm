# Phase P12: Scaling Integration — Completed

## Phase ID
`PLAN-20260223-GFX-FULL-PORT.P12`

## Timestamp
2026-02-23

## Files Modified
- `rust/src/graphics/ffi.rs`

## Functions Added
- `scale_factor_from_flags(flags: c_int) -> Option<u32>` — determines software scale factor from GFX flags (bit 7 = HQ2x/2×, bit 8 = xBRZ/3×, bit 9 = xBRZ/4×, bilinear-only returns None)
- `convert_rgbx_to_rgba(src, dst, width, height, pitch)` — RGBX8888 `[X,B,G,R]` → RGBA `[R,G,B,0xFF]` with pitch support
- `convert_rgba_to_rgbx(src, dst, width, height)` — RGBA `[R,G,B,A]` → RGBX8888 `[0xFF,B,G,R]`

## Functions Modified
- `rust_gfx_screen` — added scaled path: detects software scaling from flags, converts RGBX→RGBA, runs xBRZ or HQ2x scaler, converts RGBA→RGBX, creates scaled texture, computes scaled source rect (×factor), renders with unscaled dst rect
- `rust_gfx_postprocess` — refactored to use `convert_rgbx_to_rgba`, `convert_rgba_to_rgbx`, and `scale_factor_from_flags` helpers instead of inline pixel conversion loops (DRY)

## Tests Added
- `test_convert_rgbx_to_rgba_basic` — verifies [X,B,G,R] → [R,G,B,0xFF] conversion
- `test_convert_rgbx_to_rgba_with_pitch` — verifies conversion with pitch > width*4
- `test_convert_rgba_to_rgbx_basic` — verifies [R,G,B,A] → [0xFF,B,G,R] conversion
- `test_convert_rgbx_rgba_roundtrip` — verifies R/G/B channels survive roundtrip, X→0xFF
- `test_scale_factor_from_flags` — verifies HQ2x=2, xBRZ3=3, xBRZ4=4, xBRZ3 priority over HQ2x
- `test_bilinear_only_no_software_scale` — verifies bilinear-only (bit 3) returns None

## Verification
- `cargo test --lib graphics::ffi` — 20 passed, 0 failed, 4 ignored (need display server)
- `cargo test --lib --all-features` — 1037+ passed, pre-existing flaky test in io::uio_bridge (test execution order dependent, passes in isolation)
- No warnings in graphics/ffi.rs
- No TODO/FIXME/HACK/todo!/unimplemented! patterns in ffi.rs

## Semantic Verification
- [x] Pixel conversion matches byte ordering from REQ-SCALE-060/070
- [x] xBRZ path invokes `xbrz::scale_rgba` with correct parameters
- [x] HQ2x path invokes `state.hq2x.scale` with correct parameters
- [x] HQ2x scale factor is always 2
- [x] xBRZ3 scale factor is 3, xBRZ4 is 4
- [x] Bilinear-only flag does NOT trigger software scaling
- [x] One-time logging for scaler activation preserved (hq2x_logged, xbrz_logged)
- [x] No per-frame logging in hot path
- [x] Scaling code extracted from postprocess into helpers (not duplicated)
- [x] Postprocess refactored to use same helpers (DRY)

## Requirements Satisfied
- REQ-SCALE-010: RGBX→RGBA conversion before scaling
- REQ-SCALE-020: Scaler selection from flags
- REQ-SCALE-025: Bilinear-only skips software scaling
- REQ-SCALE-030: RGBA→RGBX conversion after scaling
- REQ-SCALE-040: Scaled texture dimensions (320×factor × 240×factor)
- REQ-SCALE-050: Scaled source rect (coordinates × factor)
- REQ-SCALE-055: Integer overflow safety (satisfied by construction)
- REQ-SCALE-060: RGBX→RGBA byte order [X,B,G,R] → [R,G,B,0xFF]
- REQ-SCALE-070: RGBA→RGBX byte order [R,G,B,A] → [0xFF,B,G,R]
- REQ-WIN-030: Source rect scaled by factor, dst rect unscaled
