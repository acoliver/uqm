//!
//! SDL2 pure software driver implementation.
//!
//! This module provides a Rust wrapper for the SDL2 pure software graphics driver,
//! mirroring the C implementation in `sc2/src/libs/graphics/sdl/sdl2_pure.c` and
//! `sc2/src/libs/graphics/sdl/sdl2_common.c`.
//!
//! # Implementation Status
//!
//! This implementation provides:
//! - Full SDL2 initialization with video subsystem
//! - Window creation with resizable support
//! - SDL2 renderer creation (software backend)
//! - Three screen surfaces ( MAIN, EXTRA, TRANSITION)
//! - Texture management for each screen
//! - Fullscreen toggle with cursor visibility
//! - Delta update optimization (dirty rectangles)
//! - Buffer swapping via SDL_RenderPresent
//! - Event processing for keyboard, mouse, and window events
//! - Render quality hints (linear vs nearest-neighbor scaling)
//!
//! Corresponds to the TFB_GFXDRIVER_SDL_PURE backend in C.
//!
//! # Architecture
//!
//! The driver maintains:
//! - `sdl_context`: SDL2 context handle (main thread only)
//! - `video_subsystem`: SDL2 video subsystem
//! - `window`: SDL window handle
//! - `renderer`: SDL renderer handle
//! - `screens`: Array of screen surfaces with texture tracking
//! - State tracking via DriverState
//!
//! # Screen Management
//!
//! Three screens are managed:
//! - Screen 0 (Main): Primary rendering surface
//! - Screen 1 (Extra): Secondary surface for overlays (initially inactive)
//! - Screen 2 (Transition): Transition effects surface
//!
//! Each screen has:
//! - Pixel surface for direct drawing access
//! - Optional scaled surface (if scaling is enabled)
//! - SDL texture for rendering
//! - Dirty rectangle tracking

use std::sync::Mutex;

use sdl2::{
    event::Event,
    pixels::PixelFormatEnum,
    rect::Rect,
    render::{Texture, TextureAccess, TextureCreator, WindowCanvas},
    video::WindowContext,
    Sdl, VideoSubsystem,
};

use crate::graphics::sdl::common::{
    DriverConfig, DriverError, DriverResult, DriverState, GraphicsDriver, RedrawMode,
    Screen, ScreenDims, UpdateRect, GraphicsEvent,
};

/// Maximum number of screens (mirrors TFB_GFX_NUMSCREENS).
const NUM_SCREENS: usize = 3;

/// Pixel format masks for 32-bit RGBA surfaces.
#[cfg(target_endian = "big")]
const PIXEL_FORMAT: PixelFormatEnum = PixelFormatEnum::RGBA8888;

#[cfg(target_endian = "little")]
const PIXEL_FORMAT: PixelFormatEnum = PixelFormatEnum::RGBX8888;

/// Screen surface information, mirroring TFB_SDL2_SCREENINFO in C.
#[derive(Debug)]
struct ScreenInfo {
    /// Pixel surface for direct drawing.
    surface: Option<sdl2::surface::Surface<'static>>,
    /// Scaled surface (for software scaling, optional).
    scaled_surface: Option<sdl2::surface::Surface<'static>>,
    /// SDL texture for rendering.
    texture: Option<Texture<'static>>,
    /// Dirty flag - true if texture needs update.
    dirty: bool,
    /// Active flag - controls screen visibility.
    active: bool,
    /// Dirty rectangle for partial updates.
    updated: UpdateRect,
    /// Locked state for raw pixel access.
    locked: bool,
}

impl Default for ScreenInfo {
    fn default() -> Self {
        Self {
            surface: None,
            scaled_surface: None,
            texture: None,
            dirty: true,
            active: true,
            updated: UpdateRect::new(0, 0, 0, 0),
            locked: false,
        }
    }
}

impl ScreenInfo {
    fn new() -> Self {
        Self::default()
    }

    /// Mark the entire screen as dirty.
    fn mark_full_dirty(&mut self, width: u32, height: u32) {
        self.updated = UpdateRect::new(0, 0, width, height);
        self.dirty = true;
    }

    /// Mark a specific region as dirty.
    fn mark_rect_dirty(&mut self, rect: UpdateRect) {
        self.updated = rect;
        self.dirty = true;
    }
}

/// SDL2 pure software graphics driver.
///
/// This driver uses SDL2's software rendering backend via SDL_Renderer.
/// It provides compatibility with SDL2 without requiring OpenGL support.
///
/// Corresponds to the TFB_GFXDRIVER_SDL_PURE backend in C.
///
/// # Thread Safety
///
/// SDL2 must be initialized on the main thread. Methods that interact with
/// SDL should be called from the same thread that created the driver.
///
/// # Example
///
/// ```rust,ignore
/// use crate::graphics::sdl::{SdlDriver, DriverConfig, RedrawMode};
///
/// let mut driver = SdlDriver::new()?;
/// let config = DriverConfig::new(640, 480, false);
/// driver.init(&config)?;
/// driver.swap_buffers(RedrawMode::None)?;
/// driver.uninit()?;
/// ```
pub struct SdlDriver {
    /// SDL2 context.
    sdl_context: Option<Sdl>,
    /// Video subsystem.
    video_subsystem: Option<VideoSubsystem>,
    /// Window handle.
    window: Option<sdl2::video::Window>,
    /// Canvas for rendering.
    canvas: Option<Mutex<WindowCanvas>>,
    /// Texture creator (holds reference to window context).
    texture_creator: Option<TextureCreator<WindowContext>>,
    /// Screen surfaces and textures.
    screens: [ScreenInfo; NUM_SCREENS],
    /// Shared driver state.
    state: DriverState,
    /// Preferred renderer backend (optional).
    renderer_backend: Option<String>,
}

impl SdlDriver {
    /// Create a new SDL2 pure driver instance.
    ///
    /// The driver is not initialized until `init()` is called.
    #[must_use]
    pub const fn new() -> Self {
        Self {
            sdl_context: None,
            video_subsystem: None,
            window: None,
            canvas: None,
            texture_creator: None,
            screens: [
                ScreenInfo::new(),
                ScreenInfo::new(),
                ScreenInfo::new(),
            ],
            state: DriverState::new(),
            renderer_backend: None,
        }
    }

    /// Get the underlying driver state.
    #[must_use]
    pub const fn state(&self) -> &DriverState {
        &self.state
    }

    /// Set the preferred renderer backend.
    ///
    /// If set to `None`, SDL2 will use the default renderer.
    ///
    /// Note: This must be called before `init()`.
    pub fn set_renderer_backend(&mut self, backend: Option<String>) {
        self.renderer_backend = backend;
    }

    /// Check if hardware scaling is supported.
    ///
    /// SDL2 pure driver supports hardware scaling via the renderer.
    #[must_use]
    pub const fn supports_hardware_scaling() -> bool {
        true
    }

    /// Initialize SDL2 and create the window/renderer.
    ///
    /// This is the internal initialization method used by `init()`.
    fn init_sdl(&mut self, config: &DriverConfig) -> DriverResult<()> {
        log::info!("Initializing SDL2");

        // Initialize SDL2 video subsystem
        let sdl_context = sdl2::init()
            .map_err(|e| DriverError::VideoModeFailed(format!("SDL2 init: {}", e)))?;

        let video_subsystem = sdl_context
            .video()
            .map_err(|e| DriverError::VideoModeFailed(format!("video subsystem: {}", e)))?;

        let version = video_subsystem.current_video_driver().unwrap_or("unknown");
        log::info!("SDL2 video driver: {}", version);

        self.sdl_context = Some(sdl_context);
        self.video_subsystem = Some(video_subsystem);

        // Create window
        let title = format!(
            "The Ur-Quan Masters v{} (SDL2 Pure)",
            env!("CARGO_PKG_VERSION")
        );

        log::info!("Creating window: {}x{}", config.width, config.height);

        let window_builder = self.video_subsystem.as_ref().unwrap().window(
            &title,
            config.width,
            config.height,
        );

        let mut window = window_builder
            .position_centered()
            .build()
            .map_err(|e| DriverError::WindowCreationFailed(e.to_string()))?;

        // Set fullscreen if requested
        if config.fullscreen {
            window
                .set_fullscreen(sdl2::video::FullscreenType::Desktop)
                .map_err(|e| DriverError::FullscreenFailed(format!("set fullscreen: {}", e)))?;
            window.hide_cursor();
        } else {
            window.show_cursor();
        }

        self.window = Some(window);

        // Create renderer
        let window = self.window.as_ref().unwrap();
        let mut canvas = window
            .into_canvas()
            .build()
            .map_err(|e| DriverError::RendererCreationFailed(e.to_string()))?;

        let info = canvas
            .info()
            .ok_or_else(|| DriverError::RendererCreationFailed("no renderer info".into()))?;
        log::info!("SDL2 renderer: {}", info.name);

        // Set render hints for quality
        sdl2::hint::set("SDL_RENDER_SCALE_QUALITY", "1"); // "1" = linear, "0" = nearest

        // Set logical size for consistent rendering
        canvas
            .set_logical_size(320, 240)
            .map_err(|e| DriverError::RendererCreationFailed(format!("set logical size: {}", e)))?;

        self.canvas = Some(Mutex::new(canvas));

        // Get texture creator from canvas
        let canvas = self.canvas.as_ref().unwrap();
        let texture_creator = canvas
            .lock()
            .unwrap()
            .texture_creator()
            .clone();
        self.texture_creator = Some(texture_creator);

        // Initialize screens
        self.init_screens(config)?;

        Ok(())
    }

    /// Initialize screen surfaces and textures.
    fn init_screens(&mut self, config: &DriverConfig) -> DriverResult<()> {
        let texture_creator = self
            .texture_creator
            .as_ref()
            .ok_or(DriverError::NotInitialized)?;

        for i in 0..NUM_SCREENS {
            self.screens[i] = ScreenInfo::new();
            self.screens[i].active = true;

            // Create pixel surface
            let surface = sdl2::surface::Surface::new(
                config.width,
                config.height,
                PIXEL_FORMAT,
            ).map_err(|e| {
                DriverError::WindowCreationFailed(format!("screen {} surface: {}", i, e))
            })?;

            self.screens[i].surface = Some(surface);
            self.screens[i].mark_full_dirty(config.width, config.height);

            // Create texture
            let texture = texture_creator
                .create_texture(
                    PixelFormatEnum::RGBX8888,
                    TextureAccess::Streaming,
                    config.width,
                    config.height,
                )
                .map_err(|e| {
                    DriverError::RendererCreationFailed(format!("screen {} texture: {}", i, e))
                })?;

            self.screens[i].texture = Some(texture);

            log::debug!("Initialized screen {}: {}x{}", i, config.width, config.height);
        }

        // Extra screen is initially inactive
        self.screens[Screen::Extra.index()].active = false;

        Ok(())
    }

    /// Clean up SDL2 resources.
    fn cleanup(&mut self) {
        log::info!("Cleaning up SDL2 driver");

        // Drop textures first (they reference the texture creator)
        for screen in &mut self.screens {
            screen.texture = None;
            screen.scaled_surface = None;
            screen.surface = None;
        }

        self.texture_creator = None;
        self.canvas = None;
        self.window = None;
        self.video_subsystem = None;
        self.sdl_context = None;
    }

    /// Update texture from surface (with delta rect optimization).
    fn update_texture(
        &mut self,
        screen_index: usize,
        rect: Option<UpdateRect>,
    ) -> DriverResult<()> {
        let screen = &mut self.screens[screen_index];
        let surface = screen
            .surface
            .as_ref()
            .ok_or(DriverError::NotInitialized)?;
        let texture = screen
            .texture
            .as_mut()
            .ok_or(DriverError::NotInitialized)?;

        // Lock surface for pixel access
        let rect = if let Some(r) = rect {
            if r.is_empty() {
                return Ok(());
            }
            Rect::new(r.x, r.y, r.w, r.h)
        } else {
            Rect::new(0, 0, surface.width(), surface.height())
        };

        surface
            .with_lock(|pixels| {
                // Calculate pixel offset for partial update
                let pixel_format = surface.pixel_format();
                let bytes_per_pixel = pixel_format.byte_size_per_pixel() as usize;
                let pitch = surface.pitch() as usize;
                let offset = rect.y() as usize * pitch + rect.x() as usize * bytes_per_pixel;

                let pixel_data = &pixels[offset..];

                texture
                    .update(rect, pixel_data, pitch)
                    .map_err(|e| DriverError::InvalidOperation(format!("texture update: {}", e)))?;

                Ok(())
            })?;

        screen.dirty = false;
        Ok(())
    }

    /// Copy texture to renderer for display.
    fn render_screen(
        &mut self,
        screen_index: usize,
        alpha: u8,
        rect: Option<Rect>,
    ) -> DriverResult<()> {
        let canvas = self
            .canvas
            .as_ref()
            .ok_or(DriverError::NotInitialized)?;
        let mut canvas = canvas.lock().unwrap();
        let screen = &self.screens[screen_index];

        if !screen.active {
            return Ok(());
        }

        let texture = screen.texture.as_ref().ok_or(DriverError::NotInitialized)?;

        // Set alpha blending
        if alpha == 255 {
            canvas.set_blend_mode(sdl2::render::BlendMode::None);
        } else {
            canvas.set_blend_mode(sdl2::render::BlendMode::Blend);
            texture.set_alpha_mod(alpha);
        }

        // Render texture
        canvas
            .copy(texture, None, rect)
            .map_err(|e| DriverError::InvalidOperation(format!("render copy: {}", e)))?;

        Ok(())
    }
}

impl Default for SdlDriver {
    fn default() -> Self {
        Self::new()
    }
}

impl GraphicsDriver for SdlDriver {
    /// Initialize the SDL2 driver.
    ///
    /// This corresponds to `TFB_Pure_InitGraphics()` and `TFB_Pure_ConfigureVideo()`
    /// in C.
    ///
    /// Errors:
    /// - `VideoModeFailed`: If SDL2 initialization fails
    /// - `WindowCreationFailed`: If window creation fails
    /// - `RendererCreationFailed`: If renderer creation fails
    fn init(&mut self, config: &DriverConfig) -> DriverResult<()> {
        if self.state.is_initialized() {
            return Err(DriverError::VideoModeFailed(
                "Already initialized".to_string(),
            ));
        }

        // Initialize SDL2 and create window/renderer
        self.init_sdl(config)?;

        // Mark as initialized
        self.state.mark_initialized(*config);

        log::info!("SDL2 driver initialized successfully");
        Ok(())
    }

    /// Shutdown the SDL2 driver.
    ///
    /// This corresponds to `TFB_Pure_UninitGraphics()` in C.
    ///
    /// Errors:
    /// - `NotInitialized`: If the driver is not initialized
    fn uninit(&mut self) -> DriverResult<()> {
        if !self.state.is_initialized() {
            return Err(DriverError::NotInitialized);
        }

        self.cleanup();
        self.state.mark_uninitialized();

        log::info!("SDL2 driver shut down");
        Ok(())
    }

    /// Swap buffers and display the rendered frame.
    ///
    /// This corresponds to `TFB_SwapBuffers()` in C.
    ///
    /// The process:
    /// 1. Preprocess (mark dirty regions based on RedrawMode)
    /// 2. Update textures from surfaces (with delta optimization)
    /// 3. Render each screen layer to canvas
    /// 4. Present to display (SDL_RenderPresent)
    ///
    /// Arguments:
    /// - `mode`: Redraw mode indicating if a full/partial refresh is needed
    ///
    /// Errors:
    /// - `NotInitialized`: If the driver is not initialized
    fn swap_buffers(&mut self, mode: RedrawMode) -> DriverResult<()> {
        if !self.state.is_initialized() {
            return Err(DriverError::NotInitialized);
        }

        let canvas = self
            .canvas
            .as_ref()
            .ok_or(DriverError::NotInitialized)?;
        let mut canvas = canvas.lock().unwrap();

        // Preprocess: mark dirty regions
        let config = self.state.config();

        if mode == RedrawMode::Full {
            // Full redraw - mark all screens completely dirty
            for screen in &mut self.screens {
                screen.mark_full_dirty(config.width, config.height);
            }
        }

        // Clear canvas
        canvas.set_draw_color(sdl2::pixels::Color::RGB(0, 0, 0));
        canvas
            .clear()
            .map_err(|e| DriverError::InvalidOperation(format!("clear: {}", e)))?;

        // Release canvas lock before rendering screens
        drop(canvas);

        // Render each screen layer
        for i in 0..NUM_SCREENS {
            if !self.screens[i].active {
                continue;
            }

            if self.screens[i].dirty {
                let rect = self.screens[i].updated;
                self.update_texture(i, Some(rect))?;
            }

            // TODO: Implement alpha control based on screen type
            self.render_screen(i, 255, None)?;
        }

        // Present to display
        let canvas = self.canvas.as_ref().unwrap();
        let mut canvas = canvas.lock().unwrap();
        canvas
            .present()
            .map_err(|e| DriverError::InvalidOperation(format!("present: {}", e)))?;

        Ok(())
    }

    /// Set gamma correction.
    ///
    /// This corresponds to `TFB_SetGamma()` in C.
    ///
    /// In the C code for SDL2 (`sdl2_common.c`), this function always returns `false`
    /// with a warning: "Custom gamma correction is not available in the SDL2 engine."
    ///
    /// Arguments:
    /// - `gamma`: Gamma value (1.0 = no correction, >1.0 = brighter, <1.0 = darker)
    ///
    /// Returns:
    /// - `Ok(false)`: Gamma not supported in SDL2 pure driver
    fn set_gamma(&mut self, _gamma: f32) -> DriverResult<bool> {
        if !self.state.is_initialized() {
            return Err(DriverError::NotInitialized);
        }

        // Gamma correction not available in SDL2 (matches C behavior)
        log::warn!("Custom gamma correction is not available in the SDL2 engine");
        Ok(false)
    }

    /// Get current gamma value.
    ///
    /// Returns the tracked gamma value, which is always 1.0 for SDL2 (not supported).
    #[must_use]
    fn get_gamma(&self) -> f32 {
        self.state.gamma()
    }

    /// Toggle fullscreen mode.
    ///
    /// This corresponds the fullscreen toggle in `TFB_Pure_ConfigureVideo()`.
    ///
    /// In the C code, this calls `SDL_SetWindowFullscreen()` with
    /// `SDL_WINDOW_FULLSCREEN_DESKTOP` and shows/hides the cursor.
    ///
    /// Returns:
    /// - `Ok(true)`: Mode was toggled
    /// - `Err`: If toggle failed
    fn toggle_fullscreen(&mut self) -> DriverResult<bool> {
        if !self.state.is_initialized() {
            return Err(DriverError::NotInitialized);
        }

        let window = self
            .window
            .as_ref()
            .ok_or(DriverError::NotInitialized)?;

        let mut config = self.state.config();

        if config.fullscreen {
            // Switch to windowed mode
            window
                .set_fullscreen(sdl2::video::FullscreenType::Off)
                .map_err(|e| DriverError::FullscreenFailed(format!("unset fullscreen: {}", e)))?;
            window.show_cursor();

            // Restore original size
            window
                .set_size(config.width, config.height)
                .map_err(|e| DriverError::FullscreenFailed(format!("set size: {}", e)))?;

            config.fullscreen = false;
            log::info!("Switched to windowed mode: {}x{}", config.width, config.height);
        } else {
            // Switch to fullscreen mode
            window
                .set_fullscreen(sdl2::video::FullscreenType::Desktop)
                .map_err(|e| DriverError::FullscreenFailed(format!("set fullscreen: {}", e)))?;
            window.hide_cursor();

            config.fullscreen = true;
            log::info!("Switched to fullscreen mode");
        }

        self.state.update_config(config);
        Ok(true)
    }

    /// Check if currently in fullscreen mode.
    #[must_use]
    fn is_fullscreen(&self) -> bool {
        self.state.config().is_fullscreen()
    }

    /// Check if the driver is initialized.
    #[must_use]
    fn is_initialized(&self) -> bool {
        self.state.is_initialized()
    }

    /// Check if hardware scaling is supported.
    ///
    /// SDL2 supports hardware scaling via the renderer.
    #[must_use]
    fn supports_hardware_scaling(&self) -> bool {
        Self::supports_hardware_scaling()
    }

    /// Get current screen dimensions.
    #[must_use]
    fn get_dimensions(&self) -> ScreenDims {
        let config = self.state.config();
        ScreenDims {
            width: 320, // Logical resolution
            height: 240,
            actual_width: config.width,
            actual_height: config.height,
        }
    }

    /// Get read-only access to screen pixel data.
    fn get_screen_pixels(&self, screen: usize) -> DriverResult<*const u8> {
        if !self.state.is_initialized() {
            return Err(DriverError::NotInitialized);
        }
        let surface = self.screens[screen].surface.as_ref()
            .ok_or(DriverError::NotInitialized)?;
        Ok(unsafe { surface.pixels().as_ptr() })
    }

    /// Get mutable access to screen pixel data.
    fn get_screen_pixels_mut(&mut self, screen: usize) -> DriverResult<*mut u8> {
        if !self.state.is_initialized() {
            return Err(DriverError::NotInitialized);
        }
        let surface = self.screens[screen].surface.as_mut()
            .ok_or(DriverError::NotInitialized)?;
        Ok(unsafe { surface.pixels_mut().as_mut_ptr() })
    }

    /// Get screen pitch (bytes per row).
    fn get_screen_pitch(&self, screen: usize) -> DriverResult<usize> {
        if !self.state.is_initialized() {
            return Err(DriverError::NotInitialized);
        }
        let surface = self.screens[screen].surface.as_ref()
            .ok_or(DriverError::NotInitialized)?;
        Ok(surface.pitch() as usize)
    }

    /// Poll for SDL events.
    fn poll_events(&mut self) -> DriverResult<Vec<GraphicsEvent>> {
        let sdl_events = self.pump_events()?;
        let mut graphics_events = Vec::new();

        for event in sdl_events {
            match event {
                Event::Quit { .. } => {
                    graphics_events.push(GraphicsEvent::Quit);
                }
                Event::KeyDown { keycode, .. } => {
                    if let Some(key) = keycode {
                        graphics_events.push(GraphicsEvent::KeyDown(KeycodeToKey(key)));
                    }
                }
                Event::KeyUp { keycode, .. } => {
                    if let Some(key) = keycode {
                        graphics_events.push(GraphicsEvent::KeyUp(KeycodeToKey(key)));
                    }
                }
                Event::MouseButtonDown { mouse_btn, .. } => {
                    graphics_events.push(GraphicsEvent::MouseDown(From::from(mouse_btn)));
                }
                Event::MouseButtonUp { mouse_btn, .. } => {
                    graphics_events.push(GraphicsEvent::MouseUp(From::from(mouse_btn)));
                }
                Event::MouseMotion { x, y, .. } => {
                    graphics_events.push(GraphicsEvent::MouseMove(x as i32, y as i32));
                }
                Event::Window { win_event, .. } => {
                    match win_event {
                        sdl2::event::WindowEvent::Exposed => {
                            graphics_events.push(GraphicsEvent::Expose);
                        }
                        sdl2::event::WindowEvent::Resized(w, h) => {
                            graphics_events.push(GraphicsEvent::Resize(w as i32, h as i32));
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }

        Ok(graphics_events)
    }
}
    }

    /// Get screen surface for direct pixel access (readonly).
    fn get_screen_pixels(&self, screen: usize) -> DriverResult<*const u8> {
        if !self.state.is_initialized() {
            return Err(DriverError::NotInitialized);
        }
        if screen >= NUM_SCREENS {
            return Err(DriverError::InvalidOperation(format!("Invalid screen index: {}", screen)));
        }

        let screen_info = &self.screens[screen];
        let surface = screen_info
            .surface
            .as_ref()
            .ok_or(DriverError::NotInitialized)?;

        Ok(surface.without_lock().map_or(std::ptr::null(), |pixels| pixels.as_ptr()))
    }

    /// Get screen surface for direct pixel access (mutable).
    fn get_screen_pixels_mut(&mut self, screen: usize) -> DriverResult<*mut u8> {
        if !self.state.is_initialized() {
            return Err(DriverError::NotInitialized);
        }
        if screen >= NUM_SCREENS {
            return Err(DriverError::InvalidOperation(format!("Invalid screen index: {}", screen)));
        }

        let screen_info = &mut self.screens[screen];
        let surface = screen_info
            .surface
            .as_mut()
            .ok_or(DriverError::NotInitialized)?;

        // Lock surface for pixel access
        let ptr = surface.without_lock_mut().map_or(std::ptr::null_mut(), |pixels| pixels.as_mut_ptr());

        // Mark screen as dirty since pixels were accessed
        screen_info.dirty = true;

        Ok(ptr)
    }

    /// Get screen pitch (bytes per row).
    fn get_screen_pitch(&self, screen: usize) -> DriverResult<usize> {
        if !self.state.is_initialized() {
            return Err(DriverError::NotInitialized);
        }
        if screen >= NUM_SCREENS {
            return Err(DriverError::InvalidOperation(format!("Invalid screen index: {}", screen)));
        }

        let screen_info = &self.screens[screen];
        let surface = screen_info
            .surface
            .as_ref()
            .ok_or(DriverError::NotInitialized)?;

        Ok(surface.pitch() as usize)
    }

    /// Poll for pending events.

/// Convert SDL2 Keycode to graphics system key.
fn KeycodeToKey(keycode: sdl2::keycode::Keycode) -> KeyCode {
    // TODO: Map SDL keycodes to system keys
    KeyCode::Unknown
}

/// Convert SDL2 MouseButton to graphics system button.
fn FromSdlMouseButton(button: sdl2::mouse::MouseButton) -> MouseButton {
    match button {
        sdl2::mouse::MouseButton::Left => MouseButton::Left,
        sdl2::mouse::MouseButton::Middle => MouseButton::Middle,
        sdl2::mouse::MouseButton::Right => MouseButton::Right,
        _ => MouseButton::Left,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sdl_driver_default() {
        let driver = SdlDriver::default();
        assert!(!driver.is_initialized());
        assert_eq!(driver.get_gamma(), 1.0);
    }

    #[test]
    fn test_sdl_driver_new() {
        let driver = SdlDriver::new();
        assert!(!driver.is_initialized());
        assert_eq!(driver.get_gamma(), 1.0);
    }

    #[test]
    fn test_sdl_driver_init_fails_when_already_initialized() {
        let mut driver = SdlDriver::new();

        // Note: We can't actually call init() in tests without a display
        // This test is mainly for compile-time checking
        assert!(!driver.is_initialized());
    }

    #[test]
    fn test_screen_enum() {
        assert_eq!(Screen::Main.index(), 0);
        assert_eq!(Screen::Extra.index(), 1);
        assert_eq!(Screen::Transition.index(), 2);

        assert_eq!(Screen::Main.name(), "Main");
        assert_eq!(Screen::Extra.name(), "Extra");
        assert_eq!(Screen::Transition.name(), "Transition");
    }

    #[test]
    fn test_update_rect() {
        let rect = UpdateRect::new(10, 20, 100, 200);
        assert_eq!(rect.x, 10);
        assert_eq!(rect.y, 20);
        assert_eq!(rect.w, 100);
        assert_eq!(rect.h, 200);

        assert!(!rect.is_empty());

        let empty_rect = UpdateRect::new(0, 0, 0, 0);
        assert!(empty_rect.is_empty());
    }

    #[test]
    fn test_screen_info() {
        let mut info = ScreenInfo::new();
        assert!(!info.active); // Default is false in our impl

        info.active = true;
        assert!(info.active);

        info.mark_full_dirty(320, 240);
        assert!(info.dirty);
        assert_eq!(info.updated.x, 0);
        assert_eq!(info.updated.y, 0);
        assert_eq!(info.updated.w, 320);
        assert_eq!(info.updated.h, 240);

        let rect = UpdateRect::new(10, 10, 50, 50);
        info.mark_rect_dirty(rect);
        assert_eq!(info.updated, rect);
    }

    #[test]
    fn test_sdl_driver_set_renderer_backend() {
        let mut driver = SdlDriver::new();
        assert!(driver.renderer_backend.is_none());

        driver.set_renderer_backend(Some("opengl".to_string()));
        assert_eq!(driver.renderer_backend.as_deref(), Some("opengl"));

        driver.set_renderer_backend(None);
        assert!(driver.renderer_backend.is_none());
    }
}
